name: CD - Build & Deploy

on:
  # FIXME
  #  push:
  #    branches: [ main ]
  #    paths:
  #      - 'application/**'
  #      - 'kubernetes/**'
  #      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
      # We only have staging
      #          - production
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  # FIXME
  ECR_REGISTRY: 123456789012.dkr.ecr.us-east-1.amazonaws.com
  EKS_CLUSTER_NAME: astro-data-pipeline-eks
  NAMESPACE: astro-pipeline

jobs:
  build-and-deploy:
    name: Build Images & Deploy
    runs-on: ubuntu-latest
    outputs:
      image-processor-image: ${{ steps.image-processor-meta.outputs.tags }}
      catalog-service-image: ${{ steps.catalog-service-meta.outputs.tags }}
      image-processor-digest: ${{ steps.image-processor-build.outputs.digest }}
      catalog-service-digest: ${{ steps.catalog-service-build.outputs.digest }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Cache Gradle dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Make gradlew executable
      run: |
        find . -name "gradlew" -exec chmod +x {} \;

    # ========== Build Applications ==========

    - name: Build Image Processor
      run: |
        cd application/image-processor
        ./gradlew clean build -x test

    - name: Build Catalog Service
      run: |
        cd application/catalog-service
        ./gradlew clean build -x test

    # ========== Docker Image Creation & Publishing ==========

    - name: Extract Image Processor metadata
      id: image-processor-meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.ECR_REGISTRY }}/astro-image-processor
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Extract Catalog Service metadata
      id: catalog-service-meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.ECR_REGISTRY }}/astro-catalog-service
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Image Processor image
      id: image-processor-build
      uses: docker/build-push-action@v5
      with:
        context: ./application/image-processor
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.image-processor-meta.outputs.tags }}
        labels: ${{ steps.image-processor-meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILD_DATE=${{ fromJSON(steps.image-processor-meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VERSION=${{ fromJSON(steps.image-processor-meta.outputs.json).labels['org.opencontainers.image.version'] }}
          REVISION=${{ fromJSON(steps.image-processor-meta.outputs.json).labels['org.opencontainers.image.revision'] }}

    - name: Build and push Catalog Service image
      id: catalog-service-build
      uses: docker/build-push-action@v5
      with:
        context: ./application/catalog-service
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.catalog-service-meta.outputs.tags }}
        labels: ${{ steps.catalog-service-meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILD_DATE=${{ fromJSON(steps.catalog-service-meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VERSION=${{ fromJSON(steps.catalog-service-meta.outputs.json).labels['org.opencontainers.image.version'] }}
          REVISION=${{ fromJSON(steps.catalog-service-meta.outputs.json).labels['org.opencontainers.image.revision'] }}

    # ========== Security Scanning ==========

    - name: Run Trivy vulnerability scanner - Image Processor
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.image-processor-meta.outputs.tags }}
        format: 'sarif'
        output: 'image-processor-trivy-results.sarif'

    - name: Run Trivy vulnerability scanner - Catalog Service
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.catalog-service-meta.outputs.tags }}
        format: 'sarif'
        output: 'catalog-service-trivy-results.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: '.'

    # ========== Upload Artifacts ==========

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: |
          application/*/build/libs/*.jar
          application/*/build/distributions/*
        retention-days: 30

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}-staging

    - name: Update deployment images
      run: |
        # Update image processor deployment
        kubectl set image deployment/image-processor \
          image-processor=${{ needs.build-and-deploy.outputs.image-processor-image }} \
          -n ${{ env.NAMESPACE }}-staging

        # Update catalog service deployment
        kubectl set image deployment/catalog-service \
          catalog-service=${{ needs.build-and-deploy.outputs.catalog-service-image }} \
          -n ${{ env.NAMESPACE }}-staging

    - name: Wait for rollout to complete
      run: |
        kubectl rollout status deployment/image-processor -n ${{ env.NAMESPACE }}-staging --timeout=600s
        kubectl rollout status deployment/catalog-service -n ${{ env.NAMESPACE }}-staging --timeout=600s

    - name: Run smoke tests
      run: |
        # Wait for services to be ready
        kubectl wait --for=condition=ready pod -l app=image-processor -n ${{ env.NAMESPACE }}-staging --timeout=300s
        kubectl wait --for=condition=ready pod -l app=catalog-service -n ${{ env.NAMESPACE }}-staging --timeout=300s

        # Run health checks
        kubectl exec -n ${{ env.NAMESPACE }}-staging deployment/image-processor -- \
          curl -f http://localhost:8081/actuator/health || exit 1
        kubectl exec -n ${{ env.NAMESPACE }}-staging deployment/catalog-service -- \
          curl -f http://localhost:8081/actuator/health || exit 1

    - name: Post deployment notification
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        text: |
          Staging deployment ${{ job.status }}
          Image Processor: ${{ needs.build-and-deploy.outputs.image-processor-image }}
          Catalog Service: ${{ needs.build-and-deploy.outputs.catalog-service-image }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

# No production
#  deploy-production:
#    name: Deploy to Production
#    runs-on: ubuntu-latest
#    needs: [build-and-deploy, deploy-staging]
#    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
#    environment: production
#
#    steps:
#    - name: Checkout code
#      uses: actions/checkout@v4
#
#    - name: Configure AWS credentials
#      uses: aws-actions/configure-aws-credentials@v4
#      with:
#        # AWS Role Trusts GitHub OIDC identity provider
#        role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE }}
#        aws-region: ${{ env.AWS_REGION }}
#
#    - name: Setup kubectl
#      uses: azure/setup-kubectl@v3
#      with:
#        version: 'v1.28.0'
#
#    - name: Update kubeconfig
#      run: |
#        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
#
#    - name: Create deployment backup
#      run: |
#        kubectl get deployment image-processor -n ${{ env.NAMESPACE }} -o yaml > image-processor-backup.yaml
#        kubectl get deployment catalog-service -n ${{ env.NAMESPACE }} -o yaml > catalog-service-backup.yaml
#
#    - name: Blue-Green Deployment
#      run: |
#        # Create green environment
#        kubectl patch deployment image-processor -n ${{ env.NAMESPACE }} \
#          -p '{"spec":{"template":{"spec":{"containers":[{"name":"image-processor","image":"${{ needs.build-and-deploy.outputs.image-processor-image }}"}]}}}}'
#        kubectl patch deployment catalog-service -n ${{ env.NAMESPACE }} \
#          -p '{"spec":{"template":{"spec":{"containers":[{"name":"catalog-service","image":"${{ needs.build-and-deploy.outputs.catalog-service-image }}"}]}}}}'
#
#    - name: Wait for production rollout
#      run: |
#        kubectl rollout status deployment/image-processor -n ${{ env.NAMESPACE }} --timeout=900s
#        kubectl rollout status deployment/catalog-service -n ${{ env.NAMESPACE }} --timeout=900s
#
#    - name: Production health checks
#      run: |
#        # Extensive health checks for production
#        kubectl wait --for=condition=ready pod -l app=image-processor -n ${{ env.NAMESPACE }} --timeout=300s
#        kubectl wait --for=condition=ready pod -l app=catalog-service -n ${{ env.NAMESPACE }} --timeout=300s
#
#        # Service health checks
#        for i in {1..5}; do
#          kubectl exec -n ${{ env.NAMESPACE }} deployment/image-processor -- \
#            curl -f http://localhost:8081/actuator/health/readiness && break
#          sleep 30
#        done
#
#        for i in {1..5}; do
#          kubectl exec -n ${{ env.NAMESPACE }} deployment/catalog-service -- \
#            curl -f http://localhost:8081/actuator/health/readiness && break
#          sleep 30
#        done
#
#    - name: Post production deployment notification
#      uses: 8398a7/action-slack@v3
#      if: always()
#      with:
#        status: ${{ job.status }}
#        channel: '#production-deployments'
#        text: |
#          ðŸš€ Production deployment ${{ job.status }}
#          Image Processor: ${{ needs.build-and-deploy.outputs.image-processor-image }}
#          Catalog Service: ${{ needs.build-and-deploy.outputs.catalog-service-image }}
#          Deployment time: ${{ github.event.head_commit.timestamp }}
#      env:
#        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}