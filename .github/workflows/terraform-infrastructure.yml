name: Terraform Infrastructure

on:
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform-infrastructure.yml'
  push:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform-infrastructure.yml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - validate
          - plan
          - apply
          - destroy
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      last_layer:
        description: 'Last layer to process (1-5)'
        required: true
        default: '3'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'
          - '5'

env:
  TF_VERSION: '1.13.3'
  AWS_REGION: us-east-1
  TF_IN_AUTOMATION: true
  TF_INPUT: false
  DEFAULT_LAST_LAYER: '3'  # Default for non-dispatch runs

permissions:
  id-token: write
  contents: read
  security-events: write  # Required for SARIF uploads

jobs:
  terraform-validate:
    name: Terraform Validation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Format Check - Layered Architecture
      run: |
        cd terraform
        # Check format for each layer
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Checking format for layer: $layer"
          terraform fmt -check -recursive -diff $layer/
        done
      continue-on-error: true

    - name: Terraform Validate - Layered Architecture
      run: |
        cd terraform
        # Validate each layer independently
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Validating layer: $layer"
          cd $layer
          terraform init -backend=false
          terraform validate
          cd ..
        done

    - name: TFLint Installation
      uses: terraform-linters/setup-tflint@v4
      with:
        tflint_version: v0.48.0

    - name: TFLint Configuration
      run: |
        cd terraform
        cat > .tflint.hcl << EOF
        plugin "aws" {
          enabled = true
          version = "0.27.0"
          source  = "github.com/terraform-linters/tflint-ruleset-aws"
        }
        
        rule "terraform_required_version" {
          enabled = true
        }
        
        rule "terraform_required_providers" {
          enabled = true
        }
        
        rule "terraform_unused_declarations" {
          enabled = true
        }
        
        rule "terraform_comment_syntax" {
          enabled = true
        }
        
        rule "terraform_documented_outputs" {
          enabled = true
        }
        
        rule "terraform_documented_variables" {
          enabled = true
        }
        
        rule "terraform_typed_variables" {
          enabled = true
        }
        
        rule "terraform_module_pinned_source" {
          enabled = true
        }
        
        rule "terraform_naming_convention" {
          enabled = true
          format  = "snake_case"
        }
        
        rule "terraform_standard_module_structure" {
          enabled = true
        }
        EOF

    - name: TFLint Run - Layered Architecture
      run: |
        cd terraform
        # Run TFLint on each layer
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Running TFLint for layer: $layer"
          cd $layer
          tflint --init
          tflint --format=compact
          cd ..
        done

    - name: Checkov Terraform Security Scan - Layered Architecture
      uses: bridgecrewio/checkov-action@master
      continue-on-error: true  # Don't fail pipeline on security findings
      with:
        directory: terraform
        framework: terraform
        # TODO maybe no path prefix?
        config_file: ../.checkov.yml
        output_format: sarif
        output_file_path: checkov-results.sarif
        download_external_modules: true

    - name: TFSec Security Scanner - Layered Architecture
      run: |
        cd terraform
        # Run TFSec on entire terraform directory
        tfsec . --format sarif --out tfsec-results.sarif || true

    - name: Upload TFSec Security Scan Results
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true  # Don't fail pipeline on upload issues
      if: always() && hashFiles('terraform/tfsec-results.sarif') != ''
      with:
        sarif_file: terraform/tfsec-results.sarif
        category: tfsec-terraform

    - name: Upload Checkov Security Scan Results
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true  # Don't fail pipeline on upload issues
      if: always() && hashFiles('checkov-results.sarif') != ''
      with:
        sarif_file: checkov-results.sarif
        category: checkov-terraform

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: inputs.action == 'plan' || inputs.action == 'apply' || github.event_name == 'pull_request'

    permissions:
      id-token: write
      contents: read
      pull-requests: write  # Required for PR comments

    outputs:
      tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        role-session-name: GitHubActions-Terraform-Plan
        aws-region: ${{ env.AWS_REGION }}
        # Explicit OIDC configuration
        audience: sts.amazonaws.com
        output-env-credentials: true

    - name: Terraform Plan - Layered Architecture
      id: tf-plan
      env:
        LAST_LAYER: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
        ENVIRONMENT: ${{ inputs.environment || 'staging' }}
      run: |
        cd terraform
        # Use the layered deployment script for planning
        chmod +x ci/deploy-layers.sh
        export exitcode=0
        ./ci/deploy-layers.sh ${ENVIRONMENT}.tfvars plan $LAST_LAYER || export exitcode=$?

        echo "exitcode=$exitcode" >> $GITHUB_OUTPUT

        if [ $exitcode -eq 1 ]; then
          echo "Terraform Plan Failed"
          exit 1
        elif [ $exitcode -eq 0 ]; then
          echo "Terraform Plan Succeeded"
        else
          echo "Terraform Plan Completed with exit code: $exitcode"
        fi

    - name: Create Terraform Plan Summary
      env:
        ENVIRONMENT: ${{ inputs.environment || 'staging' }}
      run: |
        cd terraform
        echo "## Terraform Plan Summary (${ENVIRONMENT^}) - Layered Architecture" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "✅ All layers validated and planned successfully" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Processing Configuration:" >> $GITHUB_STEP_SUMMARY
        echo "- Environment: ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
        echo "- Last layer: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Available Layers:" >> $GITHUB_STEP_SUMMARY
        echo "- 1: 01-foundation (VPC, networking, security groups)" >> $GITHUB_STEP_SUMMARY
        echo "- 2: 02-data (S3 buckets, Lambda triggers)" >> $GITHUB_STEP_SUMMARY
        echo "- 3: 03-database (RDS PostgreSQL)" >> $GITHUB_STEP_SUMMARY
        echo "- 4: 04-compute (EKS cluster)" >> $GITHUB_STEP_SUMMARY
        echo "- 5: 05-monitoring (CloudWatch, alarms)" >> $GITHUB_STEP_SUMMARY

    - name: Comment Terraform Plan on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      env:
        PLAN: "terraform\n${{ steps.tf-plan.outputs.stdout }}"
        ENVIRONMENT: ${{ inputs.environment || 'staging' }}
      with:
        script: |
          const output = `#### Terraform Plan (${process.env.ENVIRONMENT}) 📖\`${{ steps.tf-plan.outcome }}\`

          <details><summary>Show Plan (${process.env.ENVIRONMENT})</summary>

          \`\`\`\n
          ${process.env.PLAN}
          \`\`\`

          </details>

          *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })

  terraform-plan-destroy:
    name: Terraform Plan Destroy
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: inputs.action == 'destroy'

    permissions:
      id-token: write
      contents: read

    outputs:
      tfplanExitCode: ${{ steps.tf-plan-destroy.outputs.exitcode }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        role-session-name: GitHubActions-Terraform-Plan-Destroy
        aws-region: ${{ env.AWS_REGION }}
        # Explicit OIDC configuration
        audience: sts.amazonaws.com
        output-env-credentials: true

    - name: Terraform Plan Destroy - Layered Architecture
      id: tf-plan-destroy
      env:
        LAST_LAYER: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
      run: |
        cd terraform
        # Plan destruction in reverse layer order
        chmod +x ci/deploy-layers.sh
        echo "Planning destruction for ${{ inputs.environment }} environment..."
        export exitcode=0
        ./ci/deploy-layers.sh ${{ inputs.environment }}.tfvars plan $LAST_LAYER || export exitcode=$?

        echo "exitcode=$exitcode" >> $GITHUB_OUTPUT

        if [ $exitcode -eq 1 ]; then
          echo "Terraform Plan Destroy Failed"
          exit 1
        elif [ $exitcode -eq 0 ]; then
          echo "Terraform Plan Destroy Succeeded"
        else
          echo "Terraform Plan Destroy Completed with exit code: $exitcode"
        fi

    - name: Create Terraform Plan Destroy Summary
      run: |
        cd terraform
        echo "## Terraform Plan Destroy Summary (${{ inputs.environment }}) - Layered Architecture" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "⚠️ Destruction plan completed successfully" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Processing Configuration:" >> $GITHUB_STEP_SUMMARY
        echo "- Environment: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "- Last layer to destroy: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Destruction Scope:" >> $GITHUB_STEP_SUMMARY
        echo "Layers ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }} through 5 will be destroyed in reverse order" >> $GITHUB_STEP_SUMMARY

  #  terraform-plan-production:
  #    name: Terraform Plan (Production)
  #    runs-on: ubuntu-latest
  #    needs: terraform-validate
  #    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production')
  #    environment: production
  #
  #    outputs:
  #      tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}
  #
  #    steps:
  #    - name: Checkout code
  #      uses: actions/checkout@v4
  #
  #    - name: Setup Terraform
  #      uses: hashicorp/setup-terraform@v3
  #      with:
  #        terraform_version: ${{ env.TF_VERSION }}
  #
  #    - name: Configure AWS credentials
  #      uses: aws-actions/configure-aws-credentials@v4
  #      with:
  #        # AWS Role Trusts GitHub OIDC identity provider
  #        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
  #        aws-region: ${{ env.AWS_REGION }}
  #
  #    - name: Terraform Init
  #      run: |
  #        cd terraform
  #        terraform init \
  #          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
  #          -backend-config="key=production/terraform.tfstate" \
  #          -backend-config="region=${{ env.AWS_REGION }}" \
  #          -backend-config="dynamodb_table=${{ secrets.TERRAFORM_STATE_TABLE }}" \
  #          -backend-config="encrypt=true"
  #
  #    - name: Terraform Workspace
  #      run: |
  #        cd terraform
  #        terraform workspace select production || terraform workspace new production
  #
  #    - name: Terraform Plan
  #      id: tf-plan
  #      run: |
  #        cd terraform
  #        export exitcode=0
  #        terraform plan -detailed-exitcode -no-color -out=tfplan-production -var-file="prod.tfvars" || export exitcode=$?
  #
  #        echo "exitcode=$exitcode" >> $GITHUB_OUTPUT
  #
  #        if [ $exitcode -eq 1 ]; then
  #          echo "Terraform Plan Failed"
  #          exit 1
  #        elif [ $exitcode -eq 2 ]; then
  #          echo "Terraform Plan Succeeded with Changes"
  #        else
  #          echo "Terraform Plan Succeeded with No Changes"
  #        fi
  #
  #    - name: Publish Terraform Plan
  #      uses: actions/upload-artifact@v4
  #      with:
  #        name: tfplan-production
  #        path: terraform/tfplan-production
  #
  #    - name: Create Terraform Plan Summary
  #      run: |
  #        cd terraform
  #        terraform show -no-color tfplan-production > tfplan-production.txt
  #
  #        echo "## Terraform Plan Summary (Production)" >> $GITHUB_STEP_SUMMARY
  #        echo "" >> $GITHUB_STEP_SUMMARY
  #        echo "\`\`\`hcl" >> $GITHUB_STEP_SUMMARY
  #        head -100 tfplan-production.txt >> $GITHUB_STEP_SUMMARY
  #        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: needs.terraform-plan.outputs.tfplanExitCode == 0 && inputs.action == 'apply'
    environment: ${{ inputs.environment }}

    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        role-session-name: GitHubActions-Terraform-Apply
        aws-region: ${{ env.AWS_REGION }}
        # Explicit OIDC configuration
        audience: sts.amazonaws.com
        output-env-credentials: true

    - name: Terraform Apply - Layered Architecture
      env:
        LAST_LAYER: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
        ENVIRONMENT: ${{ inputs.environment }}
      run: |
        cd terraform
        # Use the layered deployment script for applying
        chmod +x ci/deploy-layers.sh
        ./ci/deploy-layers.sh ${ENVIRONMENT}.tfvars apply $LAST_LAYER

    - name: Terraform Output - Layered Architecture
      env:
        ENVIRONMENT: ${{ inputs.environment }}
      run: |
        cd terraform
        echo "## Terraform Apply Results (${ENVIRONMENT^}) - Layered Architecture" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "🚀 Infrastructure successfully applied to ${ENVIRONMENT} environment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Configuration:" >> $GITHUB_STEP_SUMMARY
        echo "- Environment: ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
        echo "- Last layer processed: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Layer Status:" >> $GITHUB_STEP_SUMMARY
        LAST_LAYER=${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
        [[ $LAST_LAYER -ge 1 ]] && echo "✅ Layer 1: Foundation (VPC, networking)" >> $GITHUB_STEP_SUMMARY || true
        [[ $LAST_LAYER -ge 2 ]] && echo "✅ Layer 2: Data (S3, Lambda)" >> $GITHUB_STEP_SUMMARY || true
        [[ $LAST_LAYER -ge 3 ]] && echo "✅ Layer 3: Database (RDS PostgreSQL)" >> $GITHUB_STEP_SUMMARY || true
        [[ $LAST_LAYER -ge 4 ]] && echo "✅ Layer 4: Compute (EKS cluster)" >> $GITHUB_STEP_SUMMARY || true
        [[ $LAST_LAYER -ge 5 ]] && echo "✅ Layer 5: Monitoring (CloudWatch)" >> $GITHUB_STEP_SUMMARY || true

    - name: Export Combined Terraform Outputs
      env:
        ENVIRONMENT: ${{ inputs.environment }}
      run: |
        cd terraform
        # Export outputs from all layers into a combined JSON
        echo '{}' > combined-outputs-${ENVIRONMENT}.json
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Collecting outputs from layer: $layer"
          if [ -f "$layer/terraform.tfstate" ]; then
            cd $layer
            terraform output -json >> ../combined-outputs-${ENVIRONMENT}.json || echo "No outputs from $layer"
            cd ..
          fi
        done

    - name: Upload Combined Terraform Outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs-${{ inputs.environment }}-layered
        path: terraform/combined-outputs-${{ inputs.environment }}.json

  terraform-apply-main:
    name: Terraform Apply (Main Branch)
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: staging
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # AWS Role Trusts GitHub OIDC identity provider
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
          role-session-name: GitHubActions-Terraform-Apply-Main
          aws-region: ${{ env.AWS_REGION }}
          # Explicit OIDC configuration
          audience: sts.amazonaws.com
          output-env-credentials: true

      - name: Terraform Plan - Staging Environment
        id: tf-plan-main
        env:
          LAST_LAYER: ${{ env.DEFAULT_LAST_LAYER }}
          ENVIRONMENT: 'staging'
        run: |
          cd terraform
          # Use the layered deployment script for planning
          chmod +x ci/deploy-layers.sh
          export exitcode=0
          ./ci/deploy-layers.sh ${ENVIRONMENT}.tfvars plan $LAST_LAYER || export exitcode=$?
          
          echo "exitcode=$exitcode" >> $GITHUB_OUTPUT
          
          if [ $exitcode -eq 1 ]; then
            echo "Terraform Plan Failed"
            exit 1
          elif [ $exitcode -eq 0 ]; then
            echo "Terraform Plan Succeeded"
          else
            echo "Terraform Plan Completed with exit code: $exitcode"
          fi

      - name: Terraform Apply - Staging Environment
        if: steps.tf-plan-main.outputs.exitcode == 0
        env:
          LAST_LAYER: ${{ env.DEFAULT_LAST_LAYER }}
          ENVIRONMENT: 'staging'
        run: |
          cd terraform
          # Use the layered deployment script for applying
          chmod +x ci/deploy-layers.sh
          ./ci/deploy-layers.sh ${ENVIRONMENT}.tfvars apply $LAST_LAYER

      - name: Terraform Output - Staging Environment
        if: steps.tf-plan-main.outputs.exitcode == 0
        env:
          ENVIRONMENT: 'staging'
        run: |
          cd terraform
          echo "## Terraform Apply Results (Staging) - Main Branch" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🚀 Infrastructure successfully applied to staging environment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration:" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: Staging" >> $GITHUB_STEP_SUMMARY
          echo "- Triggered by: PR merge to main" >> $GITHUB_STEP_SUMMARY
          echo "- Actor: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- Last layer processed: ${{ env.DEFAULT_LAST_LAYER }}" >> $GITHUB_STEP_SUMMARY

      - name: Export Combined Terraform Outputs - Staging
        if: steps.tf-plan-main.outputs.exitcode == 0
        env:
          ENVIRONMENT: 'staging'
        run: |
          cd terraform
          # Export outputs from all layers into a combined JSON
          echo '{}' > combined-outputs-${ENVIRONMENT}.json
          for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
            echo "Collecting outputs from layer: $layer"
            if [ -f "$layer/terraform.tfstate" ]; then
              cd $layer
              terraform output -json >> ../combined-outputs-${ENVIRONMENT}.json || echo "No outputs from $layer"
              cd ..
            fi
          done

      - name: Upload Combined Terraform Outputs - Staging
        if: steps.tf-plan-main.outputs.exitcode == 0
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-staging-main
          path: terraform/combined-outputs-staging.json

  # FIXME
  #    - name: Notify Staging Deployment
  #      uses: 8398a7/action-slack@v3
  #      if: always() && ${{ secrets.SLACK_WEBHOOK_URL }} != ''
  #      with:
  #        status: ${{ job.status }}
  #        channel: '#infrastructure'
  #        text: |
  #          🏗️ Terraform Apply (Staging) - Layered Architecture: ${{ job.status }}
  #          Environment: Staging
  #          Actor: ${{ github.actor }}
  #          Commit: ${{ github.sha }}
  #          Architecture: 5-Layer Enterprise Pattern
  #      env:
  #        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  #  terraform-apply-production:
  #    name: Terraform Apply (Production)
  #    runs-on: ubuntu-latest
  #    needs: terraform-plan-production
  #    if: needs.terraform-plan-production.outputs.tfplanExitCode == 2 && github.ref == 'refs/heads/main' && github.event_name == 'push'
  #    environment: production
  #
  #    steps:
  #    - name: Checkout code
  #      uses: actions/checkout@v4
  #
  #    - name: Setup Terraform
  #      uses: hashicorp/setup-terraform@v3
  #      with:
  #        terraform_version: ${{ env.TF_VERSION }}
  #
  #    - name: Configure AWS credentials
  #      uses: aws-actions/configure-aws-credentials@v4
  #      with:
  #        # AWS Role Trusts GitHub OIDC identity provider
  #        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
  #        aws-region: ${{ env.AWS_REGION }}
  #
  #    - name: Download Terraform Plan
  #      uses: actions/download-artifact@v3
  #      with:
  #        name: tfplan-production
  #        path: terraform/
  #
  #    - name: Terraform Init
  #      run: |
  #        cd terraform
  #        terraform init \
  #          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
  #          -backend-config="key=production/terraform.tfstate" \
  #          -backend-config="region=${{ env.AWS_REGION }}" \
  #          -backend-config="dynamodb_table=${{ secrets.TERRAFORM_STATE_TABLE }}" \
  #          -backend-config="encrypt=true"
  #
  #    - name: Terraform Workspace
  #      run: |
  #        cd terraform
  #        terraform workspace select production
  #
  #    - name: Terraform Apply
  #      run: |
  #        cd terraform
  #        terraform apply -auto-approve tfplan-production
  #
  #    - name: Terraform Output
  #      run: |
  #        cd terraform
  #        terraform output -json > terraform-outputs-production.json
  #
  #        echo "## Terraform Apply Results (Production)" >> $GITHUB_STEP_SUMMARY
  #        echo "" >> $GITHUB_STEP_SUMMARY
  #        echo "Infrastructure successfully applied to production environment" >> $GITHUB_STEP_SUMMARY
  #
  #    - name: Upload Terraform Outputs
  #      uses: actions/upload-artifact@v4
  #      with:
  #        name: terraform-outputs-production
  #        path: terraform/terraform-outputs-production.json
  #
  #    - name: Notify Production Deployment
  #      uses: 8398a7/action-slack@v3
  #      if: always()
  #      with:
  #        status: ${{ job.status }}
  #        channel: '#infrastructure'
  #        text: |
  #          🚀 Terraform Apply (Production): ${{ job.status }}
  #          Environment: Production
  #          Actor: ${{ github.actor }}
  #          Commit: ${{ github.sha }}
  #
  #          Infrastructure changes have been applied to production.
  #      env:
  #        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  terraform-destroy:
    name: Terraform Destroy
    runs-on: ubuntu-latest
    needs: terraform-plan-destroy
    if: needs.terraform-plan-destroy.outputs.tfplanExitCode == 0 && inputs.action == 'destroy'
    # TODO: Create and configure GitHub production environment with protection rules, then use: ${{ inputs.environment }}
    environment: staging

    permissions:
      id-token: write
      contents: read
      issues: write  # Required for manual approval
      repository-projects: read  # Required for collaborator access

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        role-session-name: GitHubActions-Terraform-Destroy
        aws-region: ${{ env.AWS_REGION }}
        # Explicit OIDC configuration
        audience: sts.amazonaws.com
        output-env-credentials: true

    - name: Terraform Destroy - Layered Architecture
      env:
        LAST_LAYER: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
      run: |
        cd terraform
        # Execute destruction using the layered deployment script
        ./ci/deploy-layers.sh ${{ inputs.environment }}.tfvars destroy $LAST_LAYER

# FIXME
#    - name: Notify Destruction
#      uses: 8398a7/action-slack@v3
#      if: always()
#      with:
#        status: ${{ job.status }}
#        channel: '#infrastructure-critical'
#        text: |
#          ⚠️ TERRAFORM DESTROY - Layered Architecture: ${{ job.status }}
#          Environment: ${{ inputs.environment }}
#          Actor: ${{ github.actor }}
#          Last Layer: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
#
#          Infrastructure layers 1-${{ inputs.last_layer || '1' }} in ${{ inputs.environment }} have been destroyed.
#          (Reverse order destruction)
#      env:
#        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}