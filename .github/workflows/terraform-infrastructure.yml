name: Terraform Infrastructure

on:
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform-infrastructure.yml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - validate
          - plan
          - apply
          - destroy
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      last_layer:
        description: 'Last layer to process (1-5)'
        required: true
        default: '3'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'
          - '5'

env:
  TF_VERSION: '1.13.3'
  AWS_REGION: us-east-1
  TF_IN_AUTOMATION: true
  TF_INPUT: false
  DEFAULT_LAST_LAYER: '3'  # Default for non-dispatch runs

permissions:
  id-token: write
  contents: read
  security-events: write  # Required for SARIF uploads

jobs:
  terraform-validate:
    name: Terraform Validation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Format Check - Layered Architecture
      run: |
        cd terraform
        # Check format for each layer
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Checking format for layer: $layer"
          terraform fmt -check -recursive -diff $layer/
        done
      continue-on-error: true

    - name: Terraform Validate - Layered Architecture
      run: |
        cd terraform
        # Validate each layer independently
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Validating layer: $layer"
          cd $layer
          terraform init -backend=false
          terraform validate
          cd ..
        done

    - name: TFLint Installation
      uses: terraform-linters/setup-tflint@v4
      with:
        tflint_version: v0.48.0

    - name: TFLint Configuration
      run: |
        cd terraform
        cat > .tflint.hcl << EOF
        plugin "aws" {
          enabled = true
          version = "0.27.0"
          source  = "github.com/terraform-linters/tflint-ruleset-aws"
        }
        
        rule "terraform_required_version" {
          enabled = true
        }
        
        rule "terraform_required_providers" {
          enabled = true
        }
        
        rule "terraform_unused_declarations" {
          enabled = true
        }
        
        rule "terraform_comment_syntax" {
          enabled = true
        }
        
        rule "terraform_documented_outputs" {
          enabled = true
        }
        
        rule "terraform_documented_variables" {
          enabled = true
        }
        
        rule "terraform_typed_variables" {
          enabled = true
        }
        
        rule "terraform_module_pinned_source" {
          enabled = true
        }
        
        rule "terraform_naming_convention" {
          enabled = true
          format  = "snake_case"
        }
        
        rule "terraform_standard_module_structure" {
          enabled = true
        }
        EOF

    - name: TFLint Run - Layered Architecture
      run: |
        cd terraform
        # Run TFLint on each layer
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Running TFLint for layer: $layer"
          cd $layer
          tflint --init
          tflint --format=compact
          cd ..
        done

    - name: Checkov Terraform Security Scan - Layered Architecture
      uses: bridgecrewio/checkov-action@master
      continue-on-error: true  # Don't fail pipeline on security findings
      with:
        directory: terraform
        framework: terraform
        # TODO maybe no path prefix?
        config_file: ../.checkov.yml
        output_format: sarif
        output_file_path: checkov-results.sarif
        download_external_modules: true

    - name: TFSec Security Scanner - Layered Architecture
      run: |
        cd terraform
        # Run TFSec on entire terraform directory
        tfsec . --format sarif --out tfsec-results.sarif || true

    - name: Upload TFSec Security Scan Results
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true  # Don't fail pipeline on upload issues
      if: always() && hashFiles('terraform/tfsec-results.sarif') != ''
      with:
        sarif_file: terraform/tfsec-results.sarif
        category: tfsec-terraform

    - name: Upload Checkov Security Scan Results
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true  # Don't fail pipeline on upload issues
      if: always() && hashFiles('checkov-results.sarif') != ''
      with:
        sarif_file: checkov-results.sarif
        category: checkov-terraform

  terraform-plan-staging:
    name: Terraform Plan (Staging)
    runs-on: ubuntu-latest
    needs: terraform-validate
    environment: staging

    permissions:
      id-token: write
      contents: read
      pull-requests: write  # Required for PR comments

    outputs:
      tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        role-session-name: GitHubActions-Terraform-Plan
        aws-region: ${{ env.AWS_REGION }}
        # Explicit OIDC configuration
        audience: sts.amazonaws.com
        output-env-credentials: true

    - name: Terraform Plan - Layered Architecture
      id: tf-plan
      env:
        LAST_LAYER: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
      run: |
        cd terraform
        # Use the layered deployment script for planning
        chmod +x ci/deploy-layers.sh
        export exitcode=0
        ./ci/deploy-layers.sh staging.tfvars plan $LAST_LAYER || export exitcode=$?

        echo "exitcode=$exitcode" >> $GITHUB_OUTPUT

        if [ $exitcode -eq 1 ]; then
          echo "Terraform Plan Failed"
          exit 1
        elif [ $exitcode -eq 0 ]; then
          echo "Terraform Plan Succeeded"
        else
          echo "Terraform Plan Completed with exit code: $exitcode"
        fi

    - name: Create Terraform Plan Summary
      run: |
        cd terraform
        echo "## Terraform Plan Summary (Staging) - Layered Architecture" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "✅ All layers validated and planned successfully" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Processing Configuration:" >> $GITHUB_STEP_SUMMARY
        echo "- Last layer: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Available Layers:" >> $GITHUB_STEP_SUMMARY
        echo "- 1: 01-foundation (VPC, networking, security groups)" >> $GITHUB_STEP_SUMMARY
        echo "- 2: 02-data (S3 buckets, Lambda triggers)" >> $GITHUB_STEP_SUMMARY
        echo "- 3: 03-database (RDS PostgreSQL)" >> $GITHUB_STEP_SUMMARY
        echo "- 4: 04-compute (EKS cluster)" >> $GITHUB_STEP_SUMMARY
        echo "- 5: 05-monitoring (CloudWatch, alarms)" >> $GITHUB_STEP_SUMMARY

    - name: Comment Terraform Plan on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      env:
        PLAN: "terraform\n${{ steps.tf-plan.outputs.stdout }}"
      with:
        script: |
          const output = `#### Terraform Plan (Staging) 📖\`${{ steps.tf-plan.outcome }}\`
          
          <details><summary>Show Plan (Staging)</summary>
          
          \`\`\`\n
          ${process.env.PLAN}
          \`\`\`
          
          </details>
          
          *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })

  #  terraform-plan-production:
  #    name: Terraform Plan (Production)
  #    runs-on: ubuntu-latest
  #    needs: terraform-validate
  #    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production')
  #    environment: production
  #
  #    outputs:
  #      tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}
  #
  #    steps:
  #    - name: Checkout code
  #      uses: actions/checkout@v4
  #
  #    - name: Setup Terraform
  #      uses: hashicorp/setup-terraform@v3
  #      with:
  #        terraform_version: ${{ env.TF_VERSION }}
  #
  #    - name: Configure AWS credentials
  #      uses: aws-actions/configure-aws-credentials@v4
  #      with:
  #        # AWS Role Trusts GitHub OIDC identity provider
  #        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
  #        aws-region: ${{ env.AWS_REGION }}
  #
  #    - name: Terraform Init
  #      run: |
  #        cd terraform
  #        terraform init \
  #          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
  #          -backend-config="key=production/terraform.tfstate" \
  #          -backend-config="region=${{ env.AWS_REGION }}" \
  #          -backend-config="dynamodb_table=${{ secrets.TERRAFORM_STATE_TABLE }}" \
  #          -backend-config="encrypt=true"
  #
  #    - name: Terraform Workspace
  #      run: |
  #        cd terraform
  #        terraform workspace select production || terraform workspace new production
  #
  #    - name: Terraform Plan
  #      id: tf-plan
  #      run: |
  #        cd terraform
  #        export exitcode=0
  #        terraform plan -detailed-exitcode -no-color -out=tfplan-production -var-file="prod.tfvars" || export exitcode=$?
  #
  #        echo "exitcode=$exitcode" >> $GITHUB_OUTPUT
  #
  #        if [ $exitcode -eq 1 ]; then
  #          echo "Terraform Plan Failed"
  #          exit 1
  #        elif [ $exitcode -eq 2 ]; then
  #          echo "Terraform Plan Succeeded with Changes"
  #        else
  #          echo "Terraform Plan Succeeded with No Changes"
  #        fi
  #
  #    - name: Publish Terraform Plan
  #      uses: actions/upload-artifact@v4
  #      with:
  #        name: tfplan-production
  #        path: terraform/tfplan-production
  #
  #    - name: Create Terraform Plan Summary
  #      run: |
  #        cd terraform
  #        terraform show -no-color tfplan-production > tfplan-production.txt
  #
  #        echo "## Terraform Plan Summary (Production)" >> $GITHUB_STEP_SUMMARY
  #        echo "" >> $GITHUB_STEP_SUMMARY
  #        echo "\`\`\`hcl" >> $GITHUB_STEP_SUMMARY
  #        head -100 tfplan-production.txt >> $GITHUB_STEP_SUMMARY
  #        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #
  terraform-apply-staging:
    name: Terraform Apply (Staging)
    runs-on: ubuntu-latest
    needs: terraform-plan-staging
    if: needs.terraform-plan-staging.outputs.tfplanExitCode == 0 && (github.ref == 'refs/heads/develop' || inputs.action == 'apply')
    environment: staging

    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        role-session-name: GitHubActions-Terraform-Apply
        aws-region: ${{ env.AWS_REGION }}
        # Explicit OIDC configuration
        audience: sts.amazonaws.com
        output-env-credentials: true

    - name: Terraform Apply - Layered Architecture
      env:
        LAST_LAYER: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
      run: |
        cd terraform
        # Use the layered deployment script for applying
        chmod +x ci/deploy-layers.sh
        ./ci/deploy-layers.sh staging.tfvars apply $LAST_LAYER

    - name: Terraform Output - Layered Architecture
      run: |
        cd terraform
        echo "## Terraform Apply Results (Staging) - Layered Architecture" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "🚀 Infrastructure successfully applied to staging environment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Configuration:" >> $GITHUB_STEP_SUMMARY
        echo "- Last layer processed: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Layer Status:" >> $GITHUB_STEP_SUMMARY
        LAST_LAYER=${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
        [[ $LAST_LAYER -ge 1 ]] && echo "✅ Layer 1: Foundation (VPC, networking)" >> $GITHUB_STEP_SUMMARY || true
        [[ $LAST_LAYER -ge 2 ]] && echo "✅ Layer 2: Data (S3, Lambda)" >> $GITHUB_STEP_SUMMARY || true
        [[ $LAST_LAYER -ge 3 ]] && echo "✅ Layer 3: Database (RDS PostgreSQL)" >> $GITHUB_STEP_SUMMARY || true
        [[ $LAST_LAYER -ge 4 ]] && echo "✅ Layer 4: Compute (EKS cluster)" >> $GITHUB_STEP_SUMMARY || true
        [[ $LAST_LAYER -ge 5 ]] && echo "✅ Layer 5: Monitoring (CloudWatch)" >> $GITHUB_STEP_SUMMARY || true

    - name: Export Combined Terraform Outputs
      run: |
        cd terraform
        # Export outputs from all layers into a combined JSON
        echo '{}' > combined-outputs-staging.json
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Collecting outputs from layer: $layer"
          if [ -f "$layer/terraform.tfstate" ]; then
            cd $layer
            terraform output -json >> ../combined-outputs-staging.json || echo "No outputs from $layer"
            cd ..
          fi
        done

    - name: Upload Combined Terraform Outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs-staging-layered
        path: terraform/combined-outputs-staging.json

  # FIXME
  #    - name: Notify Staging Deployment
  #      uses: 8398a7/action-slack@v3
  #      if: always() && ${{ secrets.SLACK_WEBHOOK_URL }} != ''
  #      with:
  #        status: ${{ job.status }}
  #        channel: '#infrastructure'
  #        text: |
  #          🏗️ Terraform Apply (Staging) - Layered Architecture: ${{ job.status }}
  #          Environment: Staging
  #          Actor: ${{ github.actor }}
  #          Commit: ${{ github.sha }}
  #          Architecture: 5-Layer Enterprise Pattern
  #      env:
  #        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  #  terraform-apply-production:
  #    name: Terraform Apply (Production)
  #    runs-on: ubuntu-latest
  #    needs: terraform-plan-production
  #    if: needs.terraform-plan-production.outputs.tfplanExitCode == 2 && github.ref == 'refs/heads/main' && github.event_name == 'push'
  #    environment: production
  #
  #    steps:
  #    - name: Checkout code
  #      uses: actions/checkout@v4
  #
  #    - name: Setup Terraform
  #      uses: hashicorp/setup-terraform@v3
  #      with:
  #        terraform_version: ${{ env.TF_VERSION }}
  #
  #    - name: Configure AWS credentials
  #      uses: aws-actions/configure-aws-credentials@v4
  #      with:
  #        # AWS Role Trusts GitHub OIDC identity provider
  #        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
  #        aws-region: ${{ env.AWS_REGION }}
  #
  #    - name: Download Terraform Plan
  #      uses: actions/download-artifact@v3
  #      with:
  #        name: tfplan-production
  #        path: terraform/
  #
  #    - name: Terraform Init
  #      run: |
  #        cd terraform
  #        terraform init \
  #          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
  #          -backend-config="key=production/terraform.tfstate" \
  #          -backend-config="region=${{ env.AWS_REGION }}" \
  #          -backend-config="dynamodb_table=${{ secrets.TERRAFORM_STATE_TABLE }}" \
  #          -backend-config="encrypt=true"
  #
  #    - name: Terraform Workspace
  #      run: |
  #        cd terraform
  #        terraform workspace select production
  #
  #    - name: Terraform Apply
  #      run: |
  #        cd terraform
  #        terraform apply -auto-approve tfplan-production
  #
  #    - name: Terraform Output
  #      run: |
  #        cd terraform
  #        terraform output -json > terraform-outputs-production.json
  #
  #        echo "## Terraform Apply Results (Production)" >> $GITHUB_STEP_SUMMARY
  #        echo "" >> $GITHUB_STEP_SUMMARY
  #        echo "Infrastructure successfully applied to production environment" >> $GITHUB_STEP_SUMMARY
  #
  #    - name: Upload Terraform Outputs
  #      uses: actions/upload-artifact@v4
  #      with:
  #        name: terraform-outputs-production
  #        path: terraform/terraform-outputs-production.json
  #
  #    - name: Notify Production Deployment
  #      uses: 8398a7/action-slack@v3
  #      if: always()
  #      with:
  #        status: ${{ job.status }}
  #        channel: '#infrastructure'
  #        text: |
  #          🚀 Terraform Apply (Production): ${{ job.status }}
  #          Environment: Production
  #          Actor: ${{ github.actor }}
  #          Commit: ${{ github.sha }}
  #
  #          Infrastructure changes have been applied to production.
  #      env:
  #        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  terraform-destroy:
    name: Terraform Destroy
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && inputs.action == 'destroy'
    environment: ${{ inputs.environment }}

    permissions:
      id-token: write
      contents: read
      issues: write  # Required for manual approval
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        role-session-name: GitHubActions-Terraform-Destroy
        aws-region: ${{ env.AWS_REGION }}
        # Explicit OIDC configuration
        audience: sts.amazonaws.com
        output-env-credentials: true

    - name: Terraform Destroy Plan - Layered Architecture
      run: |
        cd terraform
        # Plan destruction in reverse layer order
        chmod +x ci/deploy-layers.sh
        echo "Planning destruction of all layers..."
        ./ci/deploy-layers.sh ${{ inputs.environment }}.tfvars plan

    - name: Manual Approval for Destroy
      uses: trstringer/manual-approval@v1
      with:
        secret: ${{ github.token }}
        approvers: ${{ secrets.DESTROY_APPROVERS }}
        minimum-approvals: 1
        issue-title: "Terraform Destroy Approval Required"
        issue-body: |
          ⚠️ **DESTRUCTIVE ACTION** ⚠️
          
          Someone has requested to destroy infrastructure in the **${{ inputs.environment }}** environment.
          
          **Environment**: ${{ inputs.environment }}
          **Requested by**: ${{ github.actor }}
          **Workflow**: ${{ github.workflow }}
          
          Please review the destroy plan carefully before approving.

    - name: Terraform Destroy - Layered Architecture
      env:
        LAST_LAYER: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
      run: |
        cd terraform
        # Execute destruction using the layered deployment script
        ./ci/deploy-layers.sh ${{ inputs.environment }}.tfvars destroy $LAST_LAYER

# FIXME
#    - name: Notify Destruction
#      uses: 8398a7/action-slack@v3
#      if: always()
#      with:
#        status: ${{ job.status }}
#        channel: '#infrastructure-critical'
#        text: |
#          ⚠️ TERRAFORM DESTROY - Layered Architecture: ${{ job.status }}
#          Environment: ${{ inputs.environment }}
#          Actor: ${{ github.actor }}
#          Last Layer: ${{ inputs.last_layer || env.DEFAULT_LAST_LAYER }}
#
#          Infrastructure layers 1-${{ inputs.last_layer || '1' }} in ${{ inputs.environment }} have been destroyed.
#          (Reverse order destruction)
#      env:
#        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}