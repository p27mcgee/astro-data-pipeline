name: Terraform Infrastructure

on:
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform-infrastructure.yml'
  push:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform-infrastructure.yml'

env:
  TF_VERSION: '1.13.3'
  AWS_REGION: us-east-1
  TF_IN_AUTOMATION: true
  TF_INPUT: false
  DEFAULT_LAST_LAYER: '3'
  ENVIRONMENT: 'staging'

permissions:
  id-token: write
  contents: read
  security-events: write  # Required for SARIF uploads
  pull-requests: write    # Required for PR comments

jobs:
  terraform-validate:
    name: Terraform Validation
    runs-on: ubuntu-latest

    outputs:
      terraform-version: ${{ steps.extract-terraform-version.outputs.terraform-version }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Extract Terraform Version
      id: extract-terraform-version
      run: |
        cd terraform
        # Extract version from version.tf
        TERRAFORM_VERSION=$(grep 'infrastructure_version = ' version.tf | sed 's/.*= "\(.*\)"/\1/')
        echo "terraform-version=$TERRAFORM_VERSION" >> $GITHUB_OUTPUT
        echo "🏗️ **Terraform Infrastructure Version: \`$TERRAFORM_VERSION\`**" >> $GITHUB_STEP_SUMMARY

    - name: Validate Version Change (PR only)
      if: github.event_name == 'pull_request'
      env:
        TERRAFORM_VERSION: ${{ steps.extract-terraform-version.outputs.terraform-version }}
      run: |
        # Get version from main branch
        git fetch origin main
        git checkout origin/main -- terraform/version.tf
        MAIN_VERSION=$(grep 'infrastructure_version = ' terraform/version.tf | sed 's/.*= "\(.*\)"/\1/')
        git checkout - -- terraform/version.tf

        echo "Current PR terraform version: $TERRAFORM_VERSION"
        echo "Main branch terraform version: $MAIN_VERSION"

        if [ "$TERRAFORM_VERSION" = "$MAIN_VERSION" ]; then
          echo "❌ ERROR: Terraform infrastructure version must be incremented for PR merge"
          echo "Current version: $TERRAFORM_VERSION"
          echo "Please update terraform/version.tf with a new infrastructure version"
          exit 1
        else
          echo "✅ Terraform version validation passed: $MAIN_VERSION → $TERRAFORM_VERSION"
          echo "## 🎯 Infrastructure Version Update" >> $GITHUB_STEP_SUMMARY
          echo "- **Previous**: \`$MAIN_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Current**: \`$TERRAFORM_VERSION\`" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Format Check - Layered Architecture
      run: |
        cd terraform
        # Check format for each layer
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Checking format for layer: $layer"
          terraform fmt -check -recursive -diff $layer/
        done
      continue-on-error: true

    - name: Terraform Validate - Layered Architecture
      run: |
        cd terraform
        # Validate each layer independently
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Validating layer: $layer"
          cd $layer
          terraform init -backend=false
          terraform validate
          cd ..
        done

    - name: TFLint Installation
      uses: terraform-linters/setup-tflint@v4
      with:
        tflint_version: v0.48.0

    - name: TFLint Configuration
      run: |
        cd terraform
        cat > .tflint.hcl << EOF
        plugin "aws" {
          enabled = true
          version = "0.27.0"
          source  = "github.com/terraform-linters/tflint-ruleset-aws"
        }

        rule "terraform_required_version" {
          enabled = true
        }

        rule "terraform_required_providers" {
          enabled = true
        }

        rule "terraform_unused_declarations" {
          enabled = true
        }

        rule "terraform_comment_syntax" {
          enabled = true
        }

        rule "terraform_documented_outputs" {
          enabled = true
        }

        rule "terraform_documented_variables" {
          enabled = true
        }

        rule "terraform_typed_variables" {
          enabled = true
        }

        rule "terraform_module_pinned_source" {
          enabled = true
        }

        rule "terraform_naming_convention" {
          enabled = true
          format  = "snake_case"
        }

        rule "terraform_standard_module_structure" {
          enabled = true
        }
        EOF

    - name: TFLint Run - Layered Architecture
      run: |
        cd terraform
        # Run TFLint on each layer
        for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
          echo "Running TFLint for layer: $layer"
          cd $layer
          tflint --init
          tflint --format=compact
          cd ..
        done

    - name: Checkov Terraform Security Scan - Layered Architecture
      uses: bridgecrewio/checkov-action@master
      continue-on-error: true  # Don't fail pipeline on security findings
      with:
        directory: terraform
        framework: terraform
        config_file: ../.checkov.yml
        output_format: sarif
        output_file_path: checkov-results.sarif
        download_external_modules: true

    - name: TFSec Security Scanner - Layered Architecture
      run: |
        cd terraform
        # Run TFSec on entire terraform directory
        tfsec . --format sarif --out tfsec-results.sarif || true

    - name: Upload TFSec Security Scan Results
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true  # Don't fail pipeline on upload issues
      if: always() && hashFiles('terraform/tfsec-results.sarif') != ''
      with:
        sarif_file: terraform/tfsec-results.sarif
        category: tfsec-terraform

    - name: Upload Checkov Security Scan Results
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true  # Don't fail pipeline on upload issues
      if: always() && hashFiles('checkov-results.sarif') != ''
      with:
        sarif_file: checkov-results.sarif
        category: checkov-terraform

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: terraform-validate

    env:
      TERRAFORM_VERSION: ${{ needs.terraform-validate.outputs.terraform-version }}

    outputs:
      tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Display Plan Information
      run: |
        echo "🏗️ **Planning Infrastructure Version: \`$TERRAFORM_VERSION\`**" >> $GITHUB_STEP_SUMMARY

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # AWS Role Trusts GitHub OIDC identity provider
        role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
        role-session-name: GitHubActions-Terraform-Plan
        aws-region: ${{ env.AWS_REGION }}
        # Explicit OIDC configuration
        audience: sts.amazonaws.com
        output-env-credentials: true

    - name: Terraform Plan - Staging Environment
      id: tf-plan
      env:
        LAST_LAYER: ${{ env.DEFAULT_LAST_LAYER }}
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        cd terraform
        # Use the layered deployment script for planning
        chmod +x ci/deploy-layers.sh
        export exitcode=0
        ./ci/deploy-layers.sh ${ENVIRONMENT}.tfvars plan $LAST_LAYER || export exitcode=$?

        echo "exitcode=$exitcode" >> $GITHUB_OUTPUT

        if [ $exitcode -eq 1 ]; then
          echo "Terraform Plan Failed"
          exit 1
        elif [ $exitcode -eq 0 ]; then
          echo "Terraform Plan Succeeded"
        else
          echo "Terraform Plan Completed with exit code: $exitcode"
        fi

    - name: Create Terraform Plan Summary
      env:
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        cd terraform
        echo "## Terraform Plan Summary (${ENVIRONMENT^}) - Infrastructure v$TERRAFORM_VERSION" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "✅ All layers validated and planned successfully" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Processing Configuration:" >> $GITHUB_STEP_SUMMARY
        echo "- **Infrastructure Version**: \`$TERRAFORM_VERSION\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
        echo "- **Last layer**: ${{ env.DEFAULT_LAST_LAYER }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Available Layers:" >> $GITHUB_STEP_SUMMARY
        echo "- 1: 01-foundation (VPC, networking, security groups)" >> $GITHUB_STEP_SUMMARY
        echo "- 2: 02-data (S3 buckets, Lambda triggers)" >> $GITHUB_STEP_SUMMARY
        echo "- 3: 03-database (RDS PostgreSQL)" >> $GITHUB_STEP_SUMMARY
        echo "- 4: 04-compute (EKS cluster)" >> $GITHUB_STEP_SUMMARY
        echo "- 5: 05-monitoring (CloudWatch, alarms)" >> $GITHUB_STEP_SUMMARY

    - name: Comment Terraform Plan on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      env:
        PLAN: "terraform\n${{ steps.tf-plan.outputs.stdout }}"
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      with:
        script: |
          const output = `#### Terraform Plan (${process.env.ENVIRONMENT}) 📖\`${{ steps.tf-plan.outcome }}\`

          <details><summary>Show Plan (${process.env.ENVIRONMENT})</summary>

          \`\`\`\n
          ${process.env.PLAN}
          \`\`\`

          </details>

          *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [ terraform-validate, terraform-plan ]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.terraform-plan.outputs.tfplanExitCode == '0'
    environment:
      name: staging
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

    env:
      TERRAFORM_VERSION: ${{ needs.terraform-validate.outputs.terraform-version }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Display Apply Information
        run: |
          echo "🚀 **Applying Infrastructure Version: \`$TERRAFORM_VERSION\`**" >> $GITHUB_STEP_SUMMARY

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # AWS Role Trusts GitHub OIDC identity provider
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE }}
          role-session-name: GitHubActions-Terraform-Apply
          aws-region: ${{ env.AWS_REGION }}
          # Explicit OIDC configuration
          audience: sts.amazonaws.com
          output-env-credentials: true

      - name: Terraform Apply - Staging Environment
        env:
          LAST_LAYER: ${{ env.DEFAULT_LAST_LAYER }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
        run: |
          cd terraform
          # Use the layered deployment script for applying
          chmod +x ci/deploy-layers.sh
          ./ci/deploy-layers.sh ${ENVIRONMENT}.tfvars apply $LAST_LAYER

      - name: Terraform Output - Staging Environment
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
        run: |
          cd terraform
          echo "## Terraform Apply Results (${ENVIRONMENT^}) - Infrastructure v$TERRAFORM_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🚀 Infrastructure successfully applied to ${ENVIRONMENT} environment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration:" >> $GITHUB_STEP_SUMMARY
          echo "- **Infrastructure Version**: \`$TERRAFORM_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${ENVIRONMENT^}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: PR merge to main" >> $GITHUB_STEP_SUMMARY
          echo "- **Actor**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Last layer processed**: ${{ env.DEFAULT_LAST_LAYER }}" >> $GITHUB_STEP_SUMMARY

      - name: Export Combined Terraform Outputs
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
        run: |
          cd terraform
          # Export outputs from all layers into a combined JSON
          echo '{}' > combined-outputs-${ENVIRONMENT}.json
          for layer in 01-foundation 02-data 03-database 04-compute 05-monitoring; do
            echo "Collecting outputs from layer: $layer"
            if [ -f "$layer/terraform.tfstate" ]; then
              cd $layer
              terraform output -json >> ../combined-outputs-${ENVIRONMENT}.json || echo "No outputs from $layer"
              cd ..
            fi
          done

      - name: Upload Combined Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-staging-infrastructure
          path: terraform/combined-outputs-staging.json